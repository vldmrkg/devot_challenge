{"version":3,"file":"adblocker.umd.min.js","sources":["esm/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parse } from 'tldts-experimental';\nimport { FiltersEngine, Request } from '@cliqz/adblocker';\nimport { autoRemoveScript, extractFeaturesFromDOM, DOMMonitor } from '@cliqz/adblocker-content';\nfunction sleep(milliseconds) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, milliseconds);\n    });\n}\nfunction getTopLevelUrl(frame) {\n    let sourceUrl = '';\n    while (frame !== null) {\n        sourceUrl = frame.url();\n        if (sourceUrl.length !== 0) {\n            break;\n        }\n        frame = frame.parentFrame();\n    }\n    return sourceUrl;\n}\n/**\n * Create an instance of `Request` from `pw.Request`.\n */\nexport function fromPlaywrightDetails(details) {\n    const sourceUrl = getTopLevelUrl(details.frame());\n    const url = details.url();\n    const type = details.resourceType();\n    return Request.fromRawDetails({\n        _originalRequestDetails: details,\n        requestId: `${type}-${url}-${sourceUrl}`,\n        sourceUrl,\n        type,\n        url,\n    });\n}\n/**\n * Wrap `FiltersEngine` into a Playwright-friendly helper class.\n */\nexport class BlockingContext {\n    constructor(page, blocker) {\n        this.page = page;\n        this.blocker = blocker;\n        this.onFrameNavigated = (frame) => blocker.onFrameNavigated(frame);\n        this.onRequest = (route) => blocker.onRequest(route);\n    }\n    async enable() {\n        if (this.blocker.config.loadCosmeticFilters === true) {\n            // Register callback to cosmetics injection (CSS + scriptlets)\n            this.page.on('framenavigated', this.onFrameNavigated);\n            this.page.once('domcontentloaded', () => {\n                this.onFrameNavigated(this.page.mainFrame());\n            });\n        }\n        if (this.blocker.config.loadNetworkFilters === true) {\n            // NOTES:\n            //  - page.setBypassCSP(enabled) might be needed to perform\n            //  injections on some pages.\n            //  - we currently do not perform CSP headers injection as there is\n            //  currently no way to modify responses in Playwright. This feature could\n            //  easily be added if Playwright implements the required capability.\n            //\n            // Register callback for network requests filtering.\n            await this.page.route('**/*', this.onRequest);\n        }\n    }\n    async disable() {\n        if (this.blocker.config.loadNetworkFilters === true) {\n            await this.page.unroute('**/*', this.onRequest);\n        }\n        if (this.blocker.config.loadCosmeticFilters === true) {\n            this.page.off('framenavigated', this.onFrameNavigated);\n        }\n    }\n}\n/**\n * Wrap `FiltersEngine` into a Playwright-friendly helper class. It exposes\n * methods to interface with Playwright APIs needed to block ads.\n */\nexport class PlaywrightBlocker extends FiltersEngine {\n    constructor() {\n        super(...arguments);\n        this.contexts = new WeakMap();\n        // ----------------------------------------------------------------------- //\n        // PlaywrightBlocker-specific additions to FiltersEngine\n        // ----------------------------------------------------------------------- //\n        this.onFrameNavigated = async (frame) => {\n            try {\n                await this.onFrame(frame);\n            }\n            catch (ex) {\n                // Ignore\n            }\n        };\n        this.onFrame = async (frame) => {\n            const url = frame.url();\n            if (url === 'chrome-error://chromewebdata/') {\n                return;\n            }\n            // Look for all iframes in this context and check if they should be removed\n            // from the DOM completely. For this we check if their `src` or `href`\n            // attribute would be blocked by any network filter.\n            this.removeBlockedFrames(frame).catch(() => {\n                /* ignore */\n            });\n            const parsed = parse(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            // We first query for stylesheets and scriptlets which are either generic or\n            // based on the hostname of this frame. We need to get these as fast as\n            // possible to reduce blinking when page loads.\n            {\n                const { active, styles, scripts } = this.getCosmeticsFilters({\n                    domain,\n                    hostname,\n                    url,\n                    // Done once per frame.\n                    getBaseRules: true,\n                    getInjectionRules: true,\n                    getExtendedRules: true,\n                    getRulesFromHostname: true,\n                    // Will handle DOM features (see below).\n                    getRulesFromDOM: false,\n                });\n                if (active === false) {\n                    return;\n                }\n                Promise.all([\n                    this.injectScriptletsIntoFrame(frame, scripts),\n                    this.injectStylesIntoFrame(frame, styles),\n                ]).catch(() => {\n                    /* ignore */\n                });\n            }\n            // Seconde step is to start monitoring the DOM of the page in order to\n            // inject more specific selectors based on `id`, `class`, or `href` found on\n            // nodes. We first query all of them, then monitor the DOM for a few\n            // seconds (or until one of the stopping conditions is met, see below).\n            const observer = new DOMMonitor((update) => {\n                if (update.type === 'features') {\n                    const { active, styles } = this.getCosmeticsFilters({\n                        domain,\n                        hostname,\n                        url,\n                        // DOM information\n                        ...update,\n                        // Only done once per frame (see above).\n                        getBaseRules: false,\n                        getInjectionRules: false,\n                        getExtendedRules: false,\n                        getRulesFromHostname: false,\n                        // Allows to get styles for updated DOM.\n                        getRulesFromDOM: true,\n                    });\n                    // Abort if cosmetics are disabled\n                    if (active === false) {\n                        return;\n                    }\n                    this.injectStylesIntoFrame(frame, styles).catch(() => {\n                        /* ignore */\n                    });\n                }\n            });\n            // This loop will periodically check if any new custom styles should be\n            // injected in the page (using values of attributes `id`, `class`, or `href`).\n            //\n            // We stop looking in the following cases:\n            // * Frame was detached.\n            // * No new attribute was found.\n            // * Number of iterations exceeded 10 (i.e. 5 seconds).\n            // * Exception was raised.\n            //\n            // Additionally, we might stop after the first lookup if\n            // `enableMutationObserver` is disabled in config, which means that we\n            // should not actively monitor the DOM for changes.\n            let numberOfIterations = 0;\n            do {\n                if (frame.isDetached()) {\n                    break;\n                }\n                try {\n                    const foundNewFeatures = observer.handleNewFeatures(await frame.$$eval(':root', extractFeaturesFromDOM));\n                    numberOfIterations += 1;\n                    if (numberOfIterations === 10) {\n                        break;\n                    }\n                    if (foundNewFeatures === false) {\n                        break;\n                    }\n                }\n                catch (ex) {\n                    break;\n                }\n                if (this.config.enableMutationObserver === false) {\n                    break;\n                }\n                await sleep(500);\n                // eslint-disable-next-line no-constant-condition\n            } while (true);\n        };\n        this.onRequest = async (route) => {\n            const details = route.request();\n            const request = fromPlaywrightDetails(details);\n            if (this.config.guessRequestTypeFromUrl === true && request.type === 'other') {\n                request.guessTypeOfRequest();\n            }\n            const frame = details.frame();\n            if (request.isMainFrame() ||\n                (request.type === 'document' && frame !== null && frame.parentFrame() === null)) {\n                route.continue();\n                return;\n            }\n            const { redirect, match } = this.match(request);\n            if (redirect !== undefined) {\n                if (redirect.contentType.endsWith(';base64')) {\n                    route.fulfill({\n                        body: Buffer.from(redirect.body, 'base64'),\n                        contentType: redirect.contentType.slice(0, -7),\n                    });\n                }\n                else {\n                    route.fulfill({\n                        body: redirect.body,\n                        contentType: redirect.contentType,\n                    });\n                }\n            }\n            else if (match === true) {\n                route.abort('blockedbyclient');\n            }\n            else {\n                route.continue();\n            }\n        };\n    }\n    // ----------------------------------------------------------------------- //\n    // Helpers to enable and disable blocking for 'browser'\n    // ----------------------------------------------------------------------- //\n    async enableBlockingInPage(page) {\n        let context = this.contexts.get(page);\n        if (context !== undefined) {\n            return context;\n        }\n        context = new BlockingContext(page, this);\n        this.contexts.set(page, context);\n        await context.enable();\n        return context;\n    }\n    async disableBlockingInPage(page) {\n        const context = this.contexts.get(page);\n        if (context === undefined) {\n            throw new Error('Trying to disable blocking which was not enabled');\n        }\n        this.contexts.delete(page);\n        await context.disable();\n    }\n    isBlockingEnabled(page) {\n        return this.contexts.has(page);\n    }\n    async injectStylesIntoFrame(frame, styles) {\n        if (styles.length !== 0) {\n            await frame.addStyleTag({\n                content: styles,\n            });\n        }\n    }\n    async injectScriptletsIntoFrame(frame, scripts) {\n        const promises = [];\n        if (scripts.length !== 0) {\n            for (const script of scripts) {\n                promises.push(frame.addScriptTag({\n                    content: autoRemoveScript(script),\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n    /**\n     * Look for sub-frames in `frame`, check if their `src` or `href` would be\n     * blocked, and then proceed to removing them from the DOM completely.\n     */\n    async removeBlockedFrames(frame) {\n        const promises = [];\n        const sourceUrl = getTopLevelUrl(frame);\n        for (const url of await frame.$$eval('iframe[src],iframe[href]', (elements) => elements.map(({ src, href }) => src || href))) {\n            const { match } = this.match(Request.fromRawDetails({\n                url,\n                sourceUrl,\n                type: 'sub_frame',\n            }));\n            if (match) {\n                promises.push(frame\n                    .$$eval(`iframe[src=\"${url}\"],iframe[href=\"${url}\"]`, (iframes) => {\n                    var _a;\n                    for (const iframe of iframes) {\n                        (_a = iframe === null || iframe === void 0 ? void 0 : iframe.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(iframe);\n                    }\n                })\n                    .catch(() => {\n                    /* ignore */\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n}\n// Re-export symboles from @cliqz/adblocker for convenience\nexport * from '@cliqz/adblocker';\n//# sourceMappingURL=index.js.map"],"names":["sleep","milliseconds","Promise","resolve","setTimeout","getTopLevelUrl","frame","sourceUrl","url","length","parentFrame","fromPlaywrightDetails","details","type","resourceType","Request","fromRawDetails","_originalRequestDetails","requestId","BlockingContext","constructor","page","blocker","this","onFrameNavigated","onRequest","route","enable","config","loadCosmeticFilters","on","once","mainFrame","loadNetworkFilters","disable","unroute","off","PlaywrightBlocker","FiltersEngine","super","arguments","contexts","WeakMap","async","onFrame","ex","removeBlockedFrames","catch","parsed","parse","hostname","domain","active","styles","scripts","getCosmeticsFilters","getBaseRules","getInjectionRules","getExtendedRules","getRulesFromHostname","getRulesFromDOM","all","injectScriptletsIntoFrame","injectStylesIntoFrame","observer","DOMMonitor","update","numberOfIterations","isDetached","foundNewFeatures","handleNewFeatures","$$eval","extractFeaturesFromDOM","enableMutationObserver","request","guessRequestTypeFromUrl","guessTypeOfRequest","isMainFrame","continue","redirect","match","undefined","contentType","endsWith","fulfill","body","Buffer","from","slice","abort","enableBlockingInPage","context","get","set","disableBlockingInPage","Error","delete","isBlockingEnabled","has","addStyleTag","content","promises","script","push","addScriptTag","autoRemoveScript","elements","map","src","href","iframes","_a","iframe","parentNode","removeChild"],"mappings":"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"}